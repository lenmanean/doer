import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getProvider, validateProvider } from '@/lib/calendar/providers/provider-factory'
import { logger } from '@/lib/logger'
import { formatDateForDB } from '@/lib/date-utils'
import { syncCalendarEventsToTasks } from '@/lib/calendar/calendar-sync-service'
import type { GoogleCalendarEvent } from '@/lib/calendar/types'

/**
 * Check if a Google Calendar event is auto-generated (birthdays, holidays, etc.)
 */
function isGoogleAutoGeneratedEvent(event: GoogleCalendarEvent, calendarId: string): boolean {
  // Check if calendar is the Birthdays calendar
  const calendarIdLower = calendarId.toLowerCase()
  if (calendarIdLower.includes('birthday') || calendarIdLower.includes('#contacts@group.v.calendar.google.com')) {
    return true
  }

  // Check event summary for common auto-generated patterns
  const summary = event.summary?.toLowerCase() || ''
  const autoGeneratedPatterns = [
    'happy birthday',
    'birthday',
    'holiday',
    'public holiday',
    'observance',
  ]
  
  if (autoGeneratedPatterns.some(pattern => summary.includes(pattern))) {
    // Additional check: if it's a birthday-like pattern and the event ID suggests auto-generation
    if (summary.includes('birthday') || summary.includes('happy birthday')) {
      // Google auto-generated birthday events often have specific ID patterns
      // They typically start with specific prefixes or contain certain patterns
      const eventId = event.id || ''
      // Check for common Google auto-generated event ID patterns
      // These often contain long alphanumeric strings with underscores and dates
      if (eventId.includes('_') && eventId.match(/\d{8}/)) {
        // Pattern like "bns477400ibsu36sigdrl9qobc_20250506" suggests auto-generated
        return true
      }
      // If summary is exactly "Happy birthday!" or similar, it's likely auto-generated
      if (summary.trim() === 'happy birthday!' || summary.trim() === 'happy birthday') {
        return true
      }
    }
    return true
  }

  // Check for Google system calendars (holidays, etc.)
  // These often have specific calendar ID patterns
  if (calendarIdLower.includes('#holiday@group.v.calendar.google.com') ||
      calendarIdLower.includes('#en.usa@group.v.calendar.google.com')) {
    return true
  }

  return false
}

/**
 * Check if an Outlook Calendar event is auto-generated (birthdays, holidays, etc.)
 */
function isOutlookAutoGeneratedEvent(event: { id?: string; summary?: string }, calendarId: string, calendarName?: string): boolean {
  const calendarIdLower = calendarId.toLowerCase()
  const calendarNameLower = (calendarName || '').toLowerCase()
  
  // Check if calendar is the Birthdays calendar
  // Outlook typically uses calendar names like "Birthdays" or calendar IDs that contain birthday info
  if (calendarIdLower.includes('birthday') || 
      calendarNameLower.includes('birthday') ||
      calendarNameLower.includes('birthdays')) {
    return true
  }

  // Check for Outlook holiday calendars
  // Outlook holiday calendars often have names like "Holidays in [Country]" or contain "holiday"
  if (calendarIdLower.includes('holiday') || 
      calendarNameLower.includes('holiday') ||
      calendarNameLower.includes('holidays')) {
    return true
  }

  // Check event summary for common auto-generated patterns
  const summary = event.summary?.toLowerCase() || ''
  const autoGeneratedPatterns = [
    'happy birthday',
    'birthday',
    'holiday',
    'public holiday',
    'observance',
    'national holiday',
  ]
  
  if (autoGeneratedPatterns.some(pattern => summary.includes(pattern))) {
    // Additional check: if it's a birthday-like pattern
    if (summary.includes('birthday') || summary.includes('happy birthday')) {
      // Outlook auto-generated birthday events often have specific patterns
      // If summary is exactly "Happy birthday!" or similar, it's likely auto-generated
      if (summary.trim() === 'happy birthday!' || 
          summary.trim() === 'happy birthday' ||
          summary.trim() === 'birthday') {
        return true
      }
      // Outlook birthday events from contacts often have the person's name + "Birthday"
      // But we can't reliably distinguish these, so we'll rely on calendar name/ID checks
    }
    return true
  }

  return false
}

// Force dynamic rendering since we use cookies for authentication
export const dynamic = 'force-dynamic'

/**
 * Manual sync endpoint - pull events from calendar provider
 * POST /api/integrations/[provider]/sync
 * Body: { calendar_ids?: string[] } - optional, defaults to selected calendars
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { provider: string } }
) {
  try {
    const supabase = await createClient()
    const { data: { user }, error: userError } = await supabase.auth.getUser()

    if (userError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Validate provider
    let provider: 'google' | 'outlook' | 'apple'
    try {
      provider = validateProvider(params.provider)
    } catch (error) {
      return NextResponse.json(
        { error: error instanceof Error ? error.message : 'Invalid provider' },
        { status: 400 }
      )
    }

    // Get user's calendar connection
    const { data: connection, error: connectionError } = await supabase
      .from('calendar_connections')
      .select('id, selected_calendar_ids, sync_token')
      .eq('user_id', user.id)
      .eq('provider', provider)
      .single()

    if (connectionError || !connection) {
      return NextResponse.json(
        { error: `No ${provider} Calendar connection found` },
        { status: 404 }
      )
    }

    // Parse request body for optional calendar_ids and syncType
    let calendarIds = connection.selected_calendar_ids || []
    let syncType: 'full' | 'basic' = 'basic' // Default to basic sync
    
    try {
      const body = await request.json().catch(() => ({}))
      if (body.calendar_ids && Array.isArray(body.calendar_ids) && body.calendar_ids.length > 0) {
        // Security: Validate that all requested calendar IDs are in the user's selected calendars
        const validCalendarIds = body.calendar_ids.filter((id: string) => 
          connection.selected_calendar_ids?.includes(id)
        )
        if (validCalendarIds.length > 0) {
          calendarIds = validCalendarIds
        } else {
          // If none are valid, log warning but use default selected calendars
          logger.warn('Invalid calendar_ids provided, using selected calendars', {
            userId: user.id,
            requested: body.calendar_ids,
            available: connection.selected_calendar_ids,
          })
        }
      }
      
      // Accept syncType parameter
      if (body.syncType === 'full' || body.syncType === 'basic') {
        syncType = body.syncType
      }
    } catch {
      // Use default selected calendars and basic sync
    }

    if (calendarIds.length === 0) {
      return NextResponse.json(
        { error: 'No calendars selected for sync. Please select calendars in settings first.' },
        { status: 400 }
      )
    }

    // Create sync log entry
    let syncLog: { id: string } | null = null
    const { data: syncLogData, error: logError } = await supabase
      .from('calendar_sync_logs')
      .insert({
        user_id: user.id,
        calendar_connection_id: connection.id,
        sync_type: syncType === 'full' ? 'full_sync' : 'pull',
        status: 'in_progress',
        started_at: new Date().toISOString(),
      })
      .select('id')
      .single()

    if (logError) {
      logger.error('Failed to create sync log', logError as Error, {
        connectionId: connection.id,
        userId: user.id,
        errorCode: logError.code,
        errorMessage: logError.message,
        errorDetails: logError.details,
        errorHint: logError.hint,
      })
      // Continue without sync log - don't fail the entire sync
    } else {
      syncLog = syncLogData
      logger.info('Created sync log entry', {
        syncLogId: syncLog.id,
        connectionId: connection.id,
        userId: user.id,
      })
    }

    try {
      // Get provider instance
      const calendarProvider = getProvider(provider)

      // Process events per calendar to maintain calendar context
      const busySlots: any[] = []
      const plansAffected = new Set<string>()
      const processedEventIds = new Set<string>() // Track events processed in this sync to avoid double-counting
      const allDeletedEventIds: string[] = [] // Collect deleted event IDs from all calendars
      const pulledEvents: Array<{ title: string; date: string; startTime: string; endTime: string }> = [] // Track event details for sync log
      let conflictsDetected = 0
      let eventsProcessed = 0
      let nextSyncToken: string | null = null

      // Fetch events from each calendar separately to maintain calendar context
      for (const calendarId of calendarIds) {
        try {
          const fetchResult = await calendarProvider.fetchEvents(
            connection.id,
            [calendarId], // Fetch from one calendar at a time
            connection.sync_token || undefined,
            syncType
          )
          
          // Collect deleted event IDs
          if (fetchResult.deletedEventIds && fetchResult.deletedEventIds.length > 0) {
            allDeletedEventIds.push(...fetchResult.deletedEventIds)
          }

          // Store the latest sync token (for providers that use single token)
          if (fetchResult.nextSyncToken) {
            nextSyncToken = fetchResult.nextSyncToken
          }

          // Process events from this calendar
          for (const event of fetchResult.events) {
            // Skip all-day events that don't have dateTime
            if (!event.start?.dateTime && !event.start?.date) {
              continue
            }

            // Skip auto-generated calendar events (birthdays, holidays, etc.)
            let isAutoGenerated = false
            if (provider === 'google') {
              isAutoGenerated = isGoogleAutoGeneratedEvent(event as GoogleCalendarEvent, calendarId)
            } else if (provider === 'outlook') {
              // Get calendar name for Outlook (if available)
              const calendarName = calendarNameMap.get(calendarId)
              isAutoGenerated = isOutlookAutoGeneratedEvent(event, calendarId, calendarName)
            }
            
            if (isAutoGenerated) {
              logger.debug(`Skipped auto-generated ${provider} calendar event`, {
                eventId: event.id,
                summary: event.summary,
                calendarId,
                calendarName: calendarNameMap.get(calendarId),
              })
              continue
            }

            const busySlot = calendarProvider.convertToBusySlot(event, calendarId)
            if (!busySlot) {
              continue
            }

            // Check if DOER created this event
            const isDoerCreated = event.extendedProperties?.private?.['doer.task_id'] !== undefined

            // Determine if event is busy
            const isBusy = event.transparency !== 'transparent'

            // Store or update calendar event
            const startTime = new Date(event.start.dateTime || event.start.date!).toISOString()
            const endTime = new Date(event.end.dateTime || event.end.date!).toISOString()

            const eventData = {
              user_id: user.id,
              calendar_connection_id: connection.id,
              external_event_id: event.id || '',
              calendar_id: calendarId,
              summary: event.summary || null,
              description: event.description || null,
              start_time: startTime,
              end_time: endTime,
              timezone: event.start.timeZone || null,
              is_busy: isBusy,
              is_doer_created: isDoerCreated,
              external_etag: event.etag || null,
              metadata: {
                extended_properties: event.extendedProperties || {},
              },
            }

            // Create unique key for this event to track duplicates within this sync
            const eventKey = `${connection.id}:${event.id || ''}:${calendarId}`
            
            // Skip if we've already processed this event in this sync
            if (processedEventIds.has(eventKey)) {
              logger.debug('Skipped duplicate event in same sync', {
                eventId: event.id,
                summary: event.summary,
                calendarId,
              })
              continue
            }
            processedEventIds.add(eventKey)

            // Check if event already exists in database (to determine if it's new or updated)
            const { data: existingEvent } = await supabase
              .from('calendar_events')
              .select('id, is_doer_created')
              .eq('calendar_connection_id', connection.id)
              .eq('external_event_id', event.id || '')
              .eq('calendar_id', calendarId)
              .single()

            const isNewEvent = !existingEvent

            // Upsert event
            const { error: upsertError } = await supabase
              .from('calendar_events')
              .upsert(eventData, {
                onConflict: 'calendar_connection_id,external_event_id,calendar_id',
              })

            if (upsertError) {
              logger.error('Failed to upsert calendar event', upsertError as Error, { event_id: event.id })
              continue
            }

            // Only count new events that are not DOER-created
            if (isNewEvent && !isDoerCreated) {
              eventsProcessed++
              
              // Store event details for sync log
              const eventDate = new Date(startTime)
              const dateStr = eventDate.toISOString().split('T')[0]
              const startTimeStr = event.start.dateTime 
                ? new Date(event.start.dateTime).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
                : event.start.date || ''
              const endTimeStr = event.end.dateTime
                ? new Date(event.end.dateTime).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
                : event.end.date || ''
              
              pulledEvents.push({
                title: event.summary || 'Untitled Event',
                date: dateStr,
                startTime: startTimeStr,
                endTime: endTimeStr,
              })
              
              logger.info('New calendar event pulled', {
                eventId: event.id,
                summary: event.summary,
                calendarId,
                connectionId: connection.id,
              })
            } else if (isDoerCreated) {
              logger.debug('Skipped DOER-created event from pull count', {
                eventId: event.id,
                summary: event.summary,
              })
            } else {
              logger.debug('Skipped existing event from pull count', {
                eventId: event.id,
                summary: event.summary,
              })
            }

            // Check for conflicts with existing plans
            if (isBusy && !isDoerCreated) {
              const { data: conflicts } = await supabase.rpc('check_calendar_conflicts_for_plan', {
                p_user_id: user.id,
                p_plan_id: null, // Check all plans
                p_start_date: formatDateForDB(new Date(startTime)),
                p_end_date: formatDateForDB(new Date(endTime)),
              })

              if (conflicts && conflicts.length > 0) {
                conflictsDetected += conflicts.length
                conflicts.forEach((conflict: any) => {
                  if (conflict.plans_affected) {
                    conflict.plans_affected.forEach((planId: string) => {
                      plansAffected.add(planId)
                    })
                  }
                })
              }
            }

            if (isBusy) {
              busySlots.push(busySlot)
            }
          }
        } catch (calendarError) {
          // Log error for this calendar but continue with others
          logger.error(`Failed to sync calendar ${calendarId}`, calendarError as Error, {
            connectionId: connection.id,
            calendarId,
          })
          // Continue with next calendar
        }
      }

      // Update sync token and last_sync_at
      if (nextSyncToken) {
        const { error: tokenError } = await supabase
          .from('calendar_connections')
          .update({
            sync_token: nextSyncToken,
            last_sync_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          })
          .eq('id', connection.id)

        if (tokenError) {
          logger.error('Failed to update sync token', tokenError as Error, { connectionId: connection.id })
        }
      } else {
        // Update last_sync_at even if no new sync token
        await supabase
          .from('calendar_connections')
          .update({
            last_sync_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          })
          .eq('id', connection.id)
      }

      // Sync calendar events to tasks (plan_id = null, is_calendar_event = true)
      let syncResult = null
      try {
        logger.info('Starting sync calendar events to tasks', {
          connectionId: connection.id,
          userId: user.id,
          provider,
          calendarIds,
          syncType,
          deletedEventCount: allDeletedEventIds.length,
        })

        syncResult = await syncCalendarEventsToTasks(
          connection.id,
          user.id,
          provider,
          calendarIds,
          allDeletedEventIds
        )

        logger.info('Synced calendar events to tasks', {
          connectionId: connection.id,
          provider,
          tasksCreated: syncResult.tasks_created,
          tasksUpdated: syncResult.tasks_updated,
          tasksSkipped: syncResult.tasks_skipped,
          errors: syncResult.errors.length,
        })
      } catch (syncError) {
        logger.error('Failed to sync events to tasks', syncError as Error, {
          connectionId: connection.id,
          userId: user.id,
          provider,
          errorMessage: syncError instanceof Error ? syncError.message : String(syncError),
          errorStack: syncError instanceof Error ? syncError.stack : undefined,
        })
        // Don't fail the whole sync operation if task sync fails, but log the error
        syncResult = {
          tasks_created: 0,
          tasks_updated: 0,
          tasks_skipped: 0,
          errors: [syncError instanceof Error ? syncError.message : 'Unknown error during task sync'],
        }
      }

      // Update sync log
      if (syncLog) {
        const { error: updateError } = await supabase
          .from('calendar_sync_logs')
          .update({
            status: 'completed',
            events_pulled: eventsProcessed,
            conflicts_detected: conflictsDetected,
            plans_affected: Array.from(plansAffected),
            changes_summary: {
              busy_slots_count: busySlots.length,
              total_events: eventsProcessed,
              tasks_created: syncResult?.tasks_created || 0,
              tasks_updated: syncResult?.tasks_updated || 0,
              tasks_skipped: syncResult?.tasks_skipped || 0,
              pulled_events: pulledEvents, // Store event details for display
            },
            completed_at: new Date().toISOString(),
          })
          .eq('id', syncLog.id)

        if (updateError) {
          logger.error('Failed to update sync log', updateError as Error, {
            syncLogId: syncLog.id,
            connectionId: connection.id,
            errorCode: updateError.code,
            errorMessage: updateError.message,
          })
        } else {
          logger.info('Updated sync log successfully', {
            syncLogId: syncLog.id,
            eventsPulled: eventsProcessed,
            tasksCreated: syncResult?.tasks_created || 0,
          })
        }
      }

      return NextResponse.json({
        success: true,
        events_pulled: eventsProcessed,
        conflicts_detected: conflictsDetected,
        plans_affected: Array.from(plansAffected),
        busy_slots_count: busySlots.length,
        tasks_created: syncResult?.tasks_created || 0,
        tasks_updated: syncResult?.tasks_updated || 0,
        tasks_skipped: syncResult?.tasks_skipped || 0,
        sync_log_id: syncLog?.id,
      })
    } catch (syncError) {
      // Update sync log with error
      if (syncLog) {
        const { error: updateError } = await supabase
          .from('calendar_sync_logs')
          .update({
            status: 'failed',
            error_message: syncError instanceof Error ? syncError.message : 'Unknown error',
            completed_at: new Date().toISOString(),
          })
          .eq('id', syncLog.id)

        if (updateError) {
          logger.error('Failed to update sync log with error status', updateError as Error, {
            syncLogId: syncLog.id,
            connectionId: connection.id,
          })
        }
      }

      logger.error('Sync failed', syncError as Error, {
        connectionId: connection.id,
        userId: user.id,
        provider,
        errorMessage: syncError instanceof Error ? syncError.message : String(syncError),
        errorStack: syncError instanceof Error ? syncError.stack : undefined,
      })
      throw syncError
    }
  } catch (error) {
    logger.error(`Failed to sync ${params.provider} calendar`, error as Error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to sync calendar' },
      { status: 500 }
    )
  }
}

