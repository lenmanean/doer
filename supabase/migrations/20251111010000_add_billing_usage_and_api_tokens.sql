-- Migration: add billing plans, API token infrastructure, and usage accounting
-- Generated by GPT-5 Codex on 2025-11-11

-- ENUM DEFINITIONS ----------------------------------------------------------------

DO $$
BEGIN
  CREATE TYPE public.billing_cycle AS ENUM ('monthly', 'annual');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

DO $$
BEGIN
  CREATE TYPE public.subscription_status AS ENUM ('active', 'trialing', 'past_due', 'canceled');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

DO $$
BEGIN
  CREATE TYPE public.usage_metric AS ENUM ('api_credits', 'integration_actions');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

DO $$
BEGIN
  CREATE TYPE public.usage_ledger_action AS ENUM ('reserve', 'commit', 'release', 'adjust', 'reset');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

DO $$
BEGIN
  CREATE TYPE public.api_token_scope AS ENUM (
    'plans.generate',
    'plans.read',
    'plans.schedule',
    'clarify',
    'reschedules',
    'integrations',
    'admin'
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

-- BILLING PLAN TABLES -------------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.billing_plans (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  slug text NOT NULL UNIQUE,
  name text NOT NULL,
  description text,
  active boolean NOT NULL DEFAULT true,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.billing_plan_cycles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  billing_plan_id uuid NOT NULL REFERENCES public.billing_plans(id) ON DELETE CASCADE,
  cycle public.billing_cycle NOT NULL,
  api_credit_limit integer NOT NULL CHECK (api_credit_limit >= 0),
  integration_action_limit integer NOT NULL CHECK (integration_action_limit >= 0),
  price_cents integer CHECK (price_cents >= 0),
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (billing_plan_id, cycle)
);

CREATE TABLE IF NOT EXISTS public.user_plan_subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  billing_plan_cycle_id uuid NOT NULL REFERENCES public.billing_plan_cycles(id) ON DELETE RESTRICT,
  status public.subscription_status NOT NULL DEFAULT 'active',
  current_period_start date NOT NULL,
  current_period_end date NOT NULL,
  cancel_at date,
  cancel_at_period_end boolean NOT NULL DEFAULT false,
  external_customer_id text,
  external_subscription_id text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS user_plan_subscriptions_user_idx
  ON public.user_plan_subscriptions (user_id, status);

CREATE UNIQUE INDEX IF NOT EXISTS user_plan_subscriptions_active_idx
  ON public.user_plan_subscriptions (user_id)
  WHERE status IN ('active', 'trialing');

-- API TOKENS ----------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.api_tokens (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  billing_plan_cycle_id uuid REFERENCES public.billing_plan_cycles(id) ON DELETE SET NULL,
  secret_salt text NOT NULL,
  token_hash text NOT NULL UNIQUE,
  name text NOT NULL,
  description text,
  scopes public.api_token_scope[] NOT NULL DEFAULT ARRAY['plans.generate', 'plans.read']::public.api_token_scope[],
  expires_at timestamptz,
  last_used_at timestamptz,
  revoked_at timestamptz,
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.api_tokens ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'api_tokens' AND policyname = 'Users manage own API tokens'
  ) THEN
    CREATE POLICY "Users manage own API tokens"
      ON public.api_tokens
      USING (auth.uid() = user_id AND revoked_at IS NULL)
      WITH CHECK (auth.uid() = user_id);
  END IF;
END
$$;

GRANT ALL ON public.api_tokens TO postgres;
GRANT ALL ON public.api_tokens TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.api_tokens TO authenticated;

-- USAGE BALANCES & LEDGER ---------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.plan_usage_balances (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  billing_plan_cycle_id uuid REFERENCES public.billing_plan_cycles(id) ON DELETE SET NULL,
  metric public.usage_metric NOT NULL,
  cycle_start date NOT NULL,
  cycle_end date NOT NULL,
  allocation integer NOT NULL CHECK (allocation >= 0),
  used integer NOT NULL DEFAULT 0 CHECK (used >= 0),
  reserved integer NOT NULL DEFAULT 0 CHECK (reserved >= 0),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (user_id, metric, cycle_start)
);

CREATE INDEX IF NOT EXISTS plan_usage_balances_user_idx
  ON public.plan_usage_balances (user_id, metric);

ALTER TABLE public.plan_usage_balances ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'plan_usage_balances' AND policyname = 'Users can view their usage balances'
  ) THEN
    CREATE POLICY "Users can view their usage balances"
      ON public.plan_usage_balances
      FOR SELECT
      USING (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'plan_usage_balances' AND policyname = 'Service role manages usage balances'
  ) THEN
    CREATE POLICY "Service role manages usage balances"
      ON public.plan_usage_balances
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
END
$$;

GRANT ALL ON public.plan_usage_balances TO postgres;
GRANT ALL ON public.plan_usage_balances TO service_role;
GRANT SELECT ON public.plan_usage_balances TO authenticated;

CREATE TABLE IF NOT EXISTS public.usage_ledger (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  billing_plan_cycle_id uuid REFERENCES public.billing_plan_cycles(id) ON DELETE SET NULL,
  metric public.usage_metric NOT NULL,
  action public.usage_ledger_action NOT NULL,
  amount integer NOT NULL CHECK (amount >= 0),
  balance_after integer CHECK (balance_after >= 0),
  reference jsonb NOT NULL DEFAULT '{}'::jsonb,
  token_id uuid REFERENCES public.api_tokens(id) ON DELETE SET NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  recorded_by uuid,
  notes text
);

CREATE INDEX IF NOT EXISTS usage_ledger_user_idx
  ON public.usage_ledger (user_id, metric, created_at);

ALTER TABLE public.usage_ledger ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'usage_ledger' AND policyname = 'Users can view their usage ledger'
  ) THEN
    CREATE POLICY "Users can view their usage ledger"
      ON public.usage_ledger
      FOR SELECT
      USING (auth.uid() = user_id);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'usage_ledger' AND policyname = 'Service role manages usage ledger'
  ) THEN
    CREATE POLICY "Service role manages usage ledger"
      ON public.usage_ledger
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
END
$$;

GRANT ALL ON public.usage_ledger TO postgres;
GRANT ALL ON public.usage_ledger TO service_role;
GRANT SELECT ON public.usage_ledger TO authenticated;

-- FUNCTIONS -----------------------------------------------------------------------

CREATE OR REPLACE FUNCTION public.current_usage_balance(
  p_user_id uuid,
  p_metric public.usage_metric
) RETURNS public.plan_usage_balances
LANGUAGE sql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
  SELECT *
  FROM public.plan_usage_balances
  WHERE user_id = p_user_id
    AND metric = p_metric
    AND CURRENT_DATE BETWEEN cycle_start AND cycle_end
  ORDER BY cycle_end DESC
  LIMIT 1;
$$;

COMMENT ON FUNCTION public.current_usage_balance IS
  'Fetch the active usage balance row for a user and metric within the current cycle.';

CREATE OR REPLACE FUNCTION public.reserve_usage(
  p_user_id uuid,
  p_metric public.usage_metric,
  p_amount integer,
  p_reference jsonb DEFAULT '{}'::jsonb,
  p_token_id uuid DEFAULT NULL
) RETURNS TABLE (
  success boolean,
  remaining integer
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  usage_row public.plan_usage_balances;
  available integer;
BEGIN
  IF p_amount <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'RESERVE_AMOUNT_INVALID', DETAIL = 'Reserve amount must be greater than zero.';
  END IF;

  SELECT *
    INTO usage_row
  FROM public.plan_usage_balances
  WHERE user_id = p_user_id
    AND metric = p_metric
    AND CURRENT_DATE BETWEEN cycle_start AND cycle_end
  FOR UPDATE;

  IF usage_row.id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'USAGE_BALANCE_NOT_FOUND', DETAIL = 'No active usage balance for metric.';
  END IF;

  available := usage_row.allocation - usage_row.used - usage_row.reserved;

  IF available < p_amount THEN
    RETURN QUERY SELECT false, available;
    RETURN;
  END IF;

  UPDATE public.plan_usage_balances
    SET reserved = reserved + p_amount,
        updated_at = now()
    WHERE id = usage_row.id;

  INSERT INTO public.usage_ledger(
    user_id,
    billing_plan_cycle_id,
    metric,
    action,
    amount,
    balance_after,
    reference,
    token_id,
    recorded_by
  )
  VALUES (
    p_user_id,
    usage_row.billing_plan_cycle_id,
    p_metric,
    'reserve',
    p_amount,
    (usage_row.allocation - usage_row.used - usage_row.reserved) - p_amount,
    COALESCE(p_reference, '{}'::jsonb),
    p_token_id,
    auth.uid()
  );

  RETURN QUERY SELECT true, (usage_row.allocation - usage_row.used - usage_row.reserved) - p_amount;
END;
$$;

COMMENT ON FUNCTION public.reserve_usage IS
  'Atomically reserve usage credits and emit a ledger entry. Returns success flag and remaining available credits.';

CREATE OR REPLACE FUNCTION public.commit_usage(
  p_user_id uuid,
  p_metric public.usage_metric,
  p_amount integer,
  p_reference jsonb DEFAULT '{}'::jsonb,
  p_token_id uuid DEFAULT NULL
) RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  usage_row public.plan_usage_balances;
  new_available integer;
BEGIN
  IF p_amount <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'COMMIT_AMOUNT_INVALID', DETAIL = 'Commit amount must be greater than zero.';
  END IF;

  SELECT *
    INTO usage_row
  FROM public.plan_usage_balances
  WHERE user_id = p_user_id
    AND metric = p_metric
    AND CURRENT_DATE BETWEEN cycle_start AND cycle_end
  FOR UPDATE;

  IF usage_row.id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'USAGE_BALANCE_NOT_FOUND', DETAIL = 'No active usage balance for metric.';
  END IF;

  IF usage_row.reserved < p_amount THEN
    RAISE EXCEPTION USING MESSAGE = 'RESERVED_BALANCE_LOW', DETAIL = 'Reserved balance is lower than commit amount.';
  END IF;

  UPDATE public.plan_usage_balances
    SET reserved = reserved - p_amount,
        used = used + p_amount,
        updated_at = now()
    WHERE id = usage_row.id
    RETURNING allocation - used - reserved INTO new_available;

  INSERT INTO public.usage_ledger(
    user_id,
    billing_plan_cycle_id,
    metric,
    action,
    amount,
    balance_after,
    reference,
    token_id,
    recorded_by
  )
  VALUES (
    p_user_id,
    usage_row.billing_plan_cycle_id,
    p_metric,
    'commit',
    p_amount,
    new_available,
    COALESCE(p_reference, '{}'::jsonb),
    p_token_id,
    auth.uid()
  );

  RETURN new_available;
END;
$$;

COMMENT ON FUNCTION public.commit_usage IS
  'Finalize previously reserved usage credits, reducing available balance and increasing used total.';

CREATE OR REPLACE FUNCTION public.release_usage(
  p_user_id uuid,
  p_metric public.usage_metric,
  p_amount integer,
  p_reference jsonb DEFAULT '{}'::jsonb,
  p_token_id uuid DEFAULT NULL
) RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  usage_row public.plan_usage_balances;
  new_available integer;
BEGIN
  IF p_amount <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'RELEASE_AMOUNT_INVALID', DETAIL = 'Release amount must be greater than zero.';
  END IF;

  SELECT *
    INTO usage_row
  FROM public.plan_usage_balances
  WHERE user_id = p_user_id
    AND metric = p_metric
    AND CURRENT_DATE BETWEEN cycle_start AND cycle_end
  FOR UPDATE;

  IF usage_row.id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'USAGE_BALANCE_NOT_FOUND', DETAIL = 'No active usage balance for metric.';
  END IF;

  IF usage_row.reserved < p_amount THEN
    RAISE EXCEPTION USING MESSAGE = 'RESERVED_BALANCE_LOW', DETAIL = 'Reserved balance is lower than release amount.';
  END IF;

  UPDATE public.plan_usage_balances
    SET reserved = reserved - p_amount,
        updated_at = now()
    WHERE id = usage_row.id
    RETURNING allocation - used - reserved INTO new_available;

  INSERT INTO public.usage_ledger(
    user_id,
    billing_plan_cycle_id,
    metric,
    action,
    amount,
    balance_after,
    reference,
    token_id,
    recorded_by
  )
  VALUES (
    p_user_id,
    usage_row.billing_plan_cycle_id,
    p_metric,
    'release',
    p_amount,
    new_available,
    COALESCE(p_reference, '{}'::jsonb),
    p_token_id,
    auth.uid()
  );

  RETURN new_available;
END;
$$;

COMMENT ON FUNCTION public.release_usage IS
  'Return reserved credits back to the available pool without marking them as used.';

CREATE OR REPLACE FUNCTION public.reset_usage_cycle(
  p_user_id uuid,
  p_metric public.usage_metric,
  p_cycle_start date,
  p_cycle_end date,
  p_allocation integer,
  p_reference jsonb DEFAULT '{}'::jsonb
) RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  balance_id uuid;
BEGIN
  IF p_allocation < 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'ALLOCATION_INVALID', DETAIL = 'Allocation must be zero or positive.';
  END IF;

  INSERT INTO public.plan_usage_balances(
    user_id,
    billing_plan_cycle_id,
    metric,
    cycle_start,
    cycle_end,
    allocation,
    used,
    reserved
  )
  VALUES (
    p_user_id,
    (
      SELECT billing_plan_cycle_id
      FROM public.user_plan_subscriptions
      WHERE user_id = p_user_id
      ORDER BY current_period_end DESC
      LIMIT 1
    ),
    p_metric,
    p_cycle_start,
    p_cycle_end,
    p_allocation,
    0,
    0
  )
  ON CONFLICT (user_id, metric, cycle_start) DO UPDATE
    SET allocation = EXCLUDED.allocation,
        cycle_end = EXCLUDED.cycle_end,
        used = 0,
        reserved = 0,
        updated_at = now()
  RETURNING id INTO balance_id;

  INSERT INTO public.usage_ledger(
    user_id,
    billing_plan_cycle_id,
    metric,
    action,
    amount,
    balance_after,
    reference,
    recorded_by
  )
  VALUES (
    p_user_id,
    (
      SELECT billing_plan_cycle_id
      FROM public.user_plan_subscriptions
      WHERE user_id = p_user_id
      ORDER BY current_period_end DESC
      LIMIT 1
    ),
    p_metric,
    'reset',
    p_allocation,
    p_allocation,
    COALESCE(p_reference, '{}'::jsonb),
    auth.uid()
  );

  RETURN balance_id;
END;
$$;

COMMENT ON FUNCTION public.reset_usage_cycle IS
  'Reset (or initialize) a user''s usage balance for a new billing cycle and emit a ledger entry.';

GRANT EXECUTE ON FUNCTION public.current_usage_balance(uuid, public.usage_metric) TO service_role;
GRANT EXECUTE ON FUNCTION public.reserve_usage(uuid, public.usage_metric, integer, jsonb, uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.commit_usage(uuid, public.usage_metric, integer, jsonb, uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.release_usage(uuid, public.usage_metric, integer, jsonb, uuid) TO service_role;
GRANT EXECUTE ON FUNCTION public.reset_usage_cycle(uuid, public.usage_metric, date, date, integer, jsonb) TO service_role;

-- SEED DATA -----------------------------------------------------------------------

INSERT INTO public.billing_plans (slug, name, description)
VALUES
  ('basic', 'Basic', 'Free tier with limited credits'),
  ('pro', 'Pro', 'Advanced automation and increased credit limits')
ON CONFLICT (slug) DO UPDATE
  SET active = true,
      updated_at = now();

INSERT INTO public.billing_plan_cycles (billing_plan_id, cycle, api_credit_limit, integration_action_limit, price_cents, metadata)
SELECT bp.id,
       bc.cycle,
       bc.api_limit,
       bc.integration_limit,
       bc.price_cents,
       bc.metadata
FROM (
  VALUES
    ('basic', 'monthly'::public.billing_cycle, 25, 100, 0, '{}'::jsonb),
    ('pro', 'monthly'::public.billing_cycle, 100, 3000, 2000, jsonb_build_object('stripe_price_id', 'price_pro_monthly')),
    ('pro', 'annual'::public.billing_cycle, 120, 4000, 19200, jsonb_build_object('stripe_price_id', 'price_pro_annual'))
) AS bc(plan_slug, cycle, api_limit, integration_limit, price_cents, metadata)
JOIN public.billing_plans bp ON bp.slug = bc.plan_slug
ON CONFLICT (billing_plan_id, cycle) DO UPDATE
  SET api_credit_limit = EXCLUDED.api_credit_limit,
      integration_action_limit = EXCLUDED.integration_action_limit,
      price_cents = EXCLUDED.price_cents,
      metadata = EXCLUDED.metadata,
      updated_at = now();

-- VIEWS ---------------------------------------------------------------------------

CREATE OR REPLACE VIEW public.user_usage_summary AS
SELECT
  bub.user_id,
  bub.metric,
  bub.cycle_start,
  bub.cycle_end,
  bub.allocation,
  bub.used,
  bub.reserved,
  (bub.allocation - bub.used - bub.reserved) AS available,
  bpc.cycle AS billing_cycle
FROM public.plan_usage_balances bub
JOIN public.billing_plan_cycles bpc ON bpc.id = bub.billing_plan_cycle_id;

COMMENT ON VIEW public.user_usage_summary IS
  'Aggregated view of per-user usage balances including available credits.';







