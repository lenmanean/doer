[1mdiff --git a/doer/src/lib/time-block-scheduler.ts b/doer/src/lib/time-block-scheduler.ts[m
[1mindex 0b39e1e..d9ae7a4 100644[m
[1m--- a/doer/src/lib/time-block-scheduler.ts[m
[1m+++ b/doer/src/lib/time-block-scheduler.ts[m
[36m@@ -1282,19 +1282,36 @@[m [mexport function timeBlockScheduler(options: TimeBlockSchedulerOptions): {[m
   }[m
 [m
   // Retry tasks that were skipped due to unscheduled prerequisites[m
[31m-  const retryTasks = tasksSkippedDueToDependencies.filter(skipped => {[m
[31m-    // Check if all prerequisites are now scheduled[m
[31m-    if (!skipped.task.idx || !taskDependencies.has(skipped.task.idx)) return false[m
[31m-    const dependentTaskIdxs = taskDependencies.get(skipped.task.idx) || [][m
[31m-    return dependentTaskIdxs.every(depIdx => {[m
[31m-      const depTask = tasks.find(t => t.idx === depIdx)[m
[31m-      if (!depTask) return false[m
[31m-      return placements.some(p => p.task_id === depTask.id)[m
[32m+[m[32m  // Use iterative retry: keep retrying until no more tasks can be scheduled[m
[32m+[m[32m  // This handles cases where Task A depends on Task B, and Task B depends on Task C[m
[32m+[m[32m  // After C is scheduled, B gets retried. After B is scheduled, A should get retried.[m
[32m+[m[32m  let retryPass = 0[m
[32m+[m[32m  const maxRetryPasses = 10 // Safety limit to prevent infinite loops[m
[32m+[m[32m  let tasksScheduledInLastPass = true[m
[32m+[m[41m  [m
[32m+[m[32m  while (tasksScheduledInLastPass && retryPass < maxRetryPasses) {[m
[32m+[m[32m    retryPass++[m
[32m+[m[32m    tasksScheduledInLastPass = false[m
[32m+[m[41m    [m
[32m+[m[32m    const retryTasks = tasksSkippedDueToDependencies.filter(skipped => {[m
[32m+[m[32m      // Skip if already scheduled[m
[32m+[m[32m      if (placements.some(p => p.task_id === skipped.task.id)) return false[m
[32m+[m[41m      [m
[32m+[m[32m      // Check if all prerequisites are now scheduled[m
[32m+[m[32m      if (!skipped.task.idx || !taskDependencies.has(skipped.task.idx)) return false[m
[32m+[m[32m      const dependentTaskIdxs = taskDependencies.get(skipped.task.idx) || [][m
[32m+[m[32m      return dependentTaskIdxs.every(depIdx => {[m
[32m+[m[32m        const depTask = tasks.find(t => t.idx === depIdx)[m
[32m+[m[32m        if (!depTask) return false[m
[32m+[m[32m        return placements.some(p => p.task_id === depTask.id)[m
[32m+[m[32m      })[m
     })[m
[31m-  })[m
 [m
[31m-  if (retryTasks.length > 0) {[m
[31m-    console.log(`ðŸ”„ Retrying ${retryTasks.length} task(s) that were skipped due to unscheduled prerequisites`)[m
[32m+[m[32m    if (retryTasks.length === 0) {[m
[32m+[m[32m      break // No more tasks to retry[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    console.log(`ðŸ”„ Retry pass ${retryPass}: Retrying ${retryTasks.length} task(s) that were skipped due to unscheduled prerequisites`)[m
     [m
     for (const skipped of retryTasks) {[m
       const task = skipped.task[m
[36m@@ -1629,6 +1646,7 @@[m [mexport function timeBlockScheduler(options: TimeBlockSchedulerOptions): {[m
           if (unscheduledIndex !== -1) {[m
             unscheduledTasks.splice(unscheduledIndex, 1)[m
           }[m
[32m+[m[32m          tasksScheduledInLastPass = true // Mark that we scheduled a task this pass[m
           break[m
         }[m
       }[m
[36m@@ -1638,6 +1656,16 @@[m [mexport function timeBlockScheduler(options: TimeBlockSchedulerOptions): {[m
         unscheduledTasks.push(task.id)[m
       }[m
     }[m
[32m+[m[41m    [m
[32m+[m[32m    // If no tasks were scheduled in this pass, stop retrying[m
[32m+[m[32m    if (!tasksScheduledInLastPass) {[m
[32m+[m[32m      console.log(`ðŸ”„ Retry pass ${retryPass}: No tasks scheduled, stopping retry loop`)[m
[32m+[m[32m      break[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  if (retryPass >= maxRetryPasses) {[m
[32m+[m[32m    console.warn(`âš ï¸ Retry loop reached maximum passes (${maxRetryPasses}), stopping to prevent infinite loop`)[m
   }[m
 [m
   console.log('ðŸ”§ Final placements order:', placements.map(p => ({ [m
